---
title: "DSA com a B√≠blia"
subtitle: "An√°lise explorat√≥ria de dados b√≠blicos atrav√©s da linguagem R"
abstract: "Este trabalho apresenta uma an√°lise explorat√≥ria de dados b√≠blicos utilizando a linguagem R, com o objetivo de identificar padr√µes e insights relevantes sobre os textos sagrados."
keywords: [B√≠blia, R, an√°lise de dados, DSA, explora√ß√£o de dados]
author: "Guilherme Bigois"
date: 2025-02-13
lang: pt
format: html
editor: visual
toc: true
number-sections: true
code-line-numbers: true
theme:
  dark: darkly
---

## Introdu√ß√£o

Nesta se√ß√£o descreverei o motivo de cria√ß√£o do projeto, os recursos utilizados e os pr√©-requisitos t√©cnicos para execu√ß√£o do *script* em ambiente local.

### Links √∫teis

-   Link do reposit√≥rio: <https://github.com/bigois/dsa-bible>

-   Meu GitHub: [https://github.com/bigois](https://github.com/bigois/dsa-bible "Perfil do autor no GitHub")

-   Meu LinkedIn: [https://www.linkedin.com/in/bigois](https://www.linkedin.com/in/bigois/ "Perfil do autor no LinkedIn")

### Objetivo

Ap√≥s a conclus√£o do curso [R para Data Science: Conhecendo a linguagem](https://www.alura.com.br/curso-online-r-data-science-conhecendo-linguagem "Curso na plataforma Alura") da [Alura](https://www.alura.com.br "P√°gina inicial da Alura"), acredito ser interessante aplicar os conhecimentos obtidos em um projeto completamente apartado.

De maneira sucinta, neste curso aprendemos:

-   Os principais comandos e estruturas de dados do R;
-   Como utilizar [estruturas condicionais e de repeti√ß√£o](https://www.hashtagtreinamentos.com/condicionais-estruturas-de-repeticao-linguagem-r "Documenta√ß√£o sobre estruturas condicionais");
-   [An√°lise explorat√≥ria](https://ebaconline.com.br/blog/analise-exploratoria-de-dados-o-que-e "Defini√ß√£o do que √© an√°lise explorat√≥ria de dados") para responder perguntas sobre os dados;
-   Cria√ß√£o e manipula√ß√£o de [vetores](https://livro.curso-r.com/3-6-vetores.html "Documenta√ß√£o sobre vetores"), [matrizes](https://livro.curso-r.com/3-13-outros-t%C3%B3picos.html#matrizes "Artigo explicativo sobre vetores") e [fatores](https://livro.curso-r.com/3-13-outros-t%C3%B3picos.html#fatores "Artigo explicativo sobre fatores") no R.

Desta forma, tentarei replicar todo o conhecimento aprendido nesta an√°lise de base de dados SQLite.

### Por que a B√≠blia Sagrada?

Sempre achei interessantes curiosidades b√≠blicas, tais como, por exemplo, a **quantidade de cap√≠tulos dos livros de Prov√©rbios e Eclesiastes**, os quais t√™m respectivamente **31 e 12 cap√≠tulos**.

Olhando assim, at√© parece que eles foram projetados para serem lidos **um dia por m√™s** (no caso de Prov√©rbios) e **um m√™s por ano** (em se tratando de Eclesiastes).

Logo, escolhi uma base de dados que contivesse a B√≠blia Sagrada em forma f√°cil de ser acessada via SQL, contudo essa base s√≥ foi poss√≠vel de ser obtida gra√ßas ao usu√°rio do GitHub [damarals (Daniel Amaral)](https://github.com/damarals "Perfil do usu√°rio do GitHub Daniel Amaral"), o qual em seu projeto, disponibiliza diversas tradu√ß√µes da B√≠blia nos formatos XML, JSON e SQLite.

Eu escolhi a vers√£o [Almeida Revisada e Corrigida (ARC)](https://pt.wikipedia.org/wiki/Almeida_Revista_e_Corrigida "Defini√ß√£o da tradu√ß√£o ARC na Wikip√©dia"), devido √† sua familiaridade com a minha primeira B√≠blia, todavia para acessar outras tradu√ß√µes, acesse este [link](https://github.com/damarals/biblias "Projeto do Daniel Amaral no GitHub").

### Pr√©-requisitos

Nesta se√ß√£o listo os arquivos e bin√°rios necess√°rios para a execu√ß√£o bem-sucedida do programa.

#### Base de dados

Para execu√ß√£o deste *script* ser√° necess√°ria a exist√™ncia de uma das tradu√ß√µes da B√≠blia em formato .sqlite contidas no projeto acima citado.

As primeiras linhas do *script* ir√£o perguntar pelo caminho do arquivo, por√©m √© poss√≠vel fixar o caminho diretamente no c√≥digo atrav√©s da vari√°vel `path`:

```{r}
# path <- file.choose()

# Caso prefira, fixe o caminho para agilizar a execu√ß√£o do script
path <- "C:\\Users\\bigois\\Documents\\Projetos\\dsa-bible\\data\\ARC.sqlite"
```

#### Vers√£o do R

Para este projeto, foi utilizada a vers√£o [4.3.3 (2024-02-29 ucrt)](https://cran.r-project.org/bin/windows/base/old/4.3.3/ "Central para download da vers√£o do R deste projeto") da linguagem R:

```{r}
R.version
```

## Carga de dados

Nesta se√ß√£o, iremos realizar a extra√ß√£o dos dados necess√°rios para nossa an√°lise.

### Instala√ß√£o de bibliotecas

Para execu√ß√£o deste c√≥digo, precisaremos das seguintes bibliotecas:

-   [RSQLite](https://rsqlite.r-dbi.org/ "P√°gina do pacote RSQLite"): Conex√£o em base de dados SQLite;
-   [glue](https://glue.tidyverse.org/ "P√°gina do pacote glue"): Interpola√ß√£o de cadeia de caracteres (*string*);
-   [dplyr](https://dplyr.tidyverse.org/ "P√°gina do pacote dplyr"): Manipula√ß√£o de transforma√ß√£o de dados.

```{r warning=FALSE, message=FALSE}
libs <- c("RSQLite", "glue", "dplyr")
for (lib in libs) {
  if (!require(lib, quietly = TRUE, character.only = TRUE)) {
    install.packages(lib)
    library(lib, character.only = TRUE)
  }
}
```

### Conex√£o com a base de dados

Para realizar a conex√£o com a base de dados, utilizaremos as fun√ß√µes `dbConnect` e `SQLite()` para definir o driver e o objeto de conex√£o:

```{r}
con <- dbConnect(SQLite(), path)
tables <- dbListTables(con)
tables
```

### Obtendo dados

Inicialmente vamos carregar todos os dados de forma completa em objetos da linguagem R, contudo √© importante enfatizar **que muitos dos relacionamentos que faremos atrav√©s do R, poderiam ser facilmente tratados com comandos SQL**, tais como `JOIN`, `MAX`, `MIN` e `AVG`.

Neste ponto, criaremos um objeto para cada tabela atrav√©s de cria√ß√£o e atribui√ß√£o din√¢mica de vari√°veis por meio do uso da fun√ß√£o `assign`, contudo para definir as vari√°veis e criar as consultas SQL, utilizaremos as fun√ß√µes `glue_sql` e `glue` do pacote `glue`:

```{r}
for (table in tables) {
  data <- dbGetQuery(con, glue_sql("SELECT * FROM {`table`}", .con = con))
  assign(glue("db_{table}"), data)
}

head(db_metadata, 3)
head(db_testament, 3)
head(db_book, 3)
head(db_verse, 3)
```

### Fechando conex√£o

Uma vez que os dados necess√°rios j√° foram obtidos, √© uma **boa pr√°tica** fechar a conex√£o com a base de dados:

```{r}
dbDisconnect(con)
```

## Tratamento de dados

Dentre as etapas de um [ETL (*Extract*, *Transform*, *Load*)](https://aws.amazon.com/pt/what-is/etl/ "Defini√ß√£o do que √© um ETL"), a se√ß√£o anterior se encaixaria como letra "E" (*extract*), assim como esta se√ß√£o teria a letra "T" (*transform*) como bem apropriada.

Isto posto, iremos manipular os *data frames* criados de forma a prepar√°-los para a nossa terceira parte, a an√°lise dos dados:

### Tabela com relacionamentos

Neste ponto, criaremos um objeto chamado `db_full` contendo apenas os dados macro de cada livro da B√≠blia, sendo eles:

-   `testament_name`: T√≠tulo de parte da B√≠blia;
-   `book_name`: Nome do livro;
-   `total_chapters`: Total de cap√≠tulos contidos no livro;
-   `total_verses`: Total de vers√≠culos do livro como um todo;
-   `total_characters`: Total de caracteres por vers√≠culo;

Contudo para que isto seja poss√≠vel e f√°cil de realizar, utilizaremos a fun√ß√£o `inner_join` da biblioteca `dplyr`:

```{r}
db_full <- db_testament %>%
  inner_join(db_book, by = c("id" = "testament_reference_id")) %>%
  inner_join(db_verse, by = c("book_reference_id" = "book_id"))

head(db_full, 3)
```

### Renomeando dados

Como pode ser visto no resultado do *chunk* anterior, ap√≥s o relacionamento das tabelas, as colunas `id` e `name` passaram a se chamar `id.x`, `id.y`, `name.x` e `name.y`, isto posto, iremos alterar o nome dessas colunas por meio da fun√ß√£o `rename`, tamb√©m do pacote `dplyr`:

```{r}
db_full <- db_full %>%
  rename(testament_name = name.x) %>%
  rename(book_name = name.y)

head(db_full, 3)
```

### Criando novas colunas

Atualmente temos a coluna `text`, a qual cont√©m o texto propriamente dito de cada vers√≠culo, contudo para nossa an√°lise, iremos calcular **apenas a quantidade de caracteres contidos em cada vers√≠culo** por meio das fun√ß√µes `mutate` (dplyr) e `nchar` (base):

```{r}
db_full <- db_full %>%
  mutate(total_characters = nchar(text))

head(db_full, 3)
```

### Removendo colunas

2/4 do nosso objetivo para esta se√ß√£o j√° est√£o conclu√≠dos, pois criamos as colunas `testament_name` e `book_name`, agora s√≥ falta criar as colunas `total_chapters` e `total_verses`.

Contudo, temos algumas colunas como `id.x`, `id.y`, `id.y.y` e `book_reference_id` que por momento n√£o iremos utilizar.

Assim sendo, removeremos essas colunas com o uso da fun√ß√£o `select` tamb√©m contida no pacote `dplyr` em conjunto com o operador `-`:

```{r}
db_full <- db_full %>%
  select(-id.x, -id.y, -id.y.y, -book_reference_id)

head(db_full, 3)
```

### Agrupamento e contagem

Agora precisamos **contar os vers√≠culos e caracteres por cap√≠tulo** e para isso utilizaremos as fun√ß√µes `group_by` e `summarize` e criaremos um objeto chamado `db_by_chapter`:

```{r message=FALSE}
db_by_chapter <- db_full %>%
  select(-text) %>%
  group_by(testament_name, book_name, chapter) %>%
  summarize(
    total_verses = n(),
    total_characters = sum(total_characters)
  )

head(db_by_chapter, 3)
```

Uma vez contados os vers√≠culos e caracteres por cap√≠tulo, agora iremos **somar os cap√≠tulos por livro** e atribu√≠-los ao objeto `db_by_book`:

```{r message=FALSE}
db_by_book <- db_by_chapter %>%
  group_by(testament_name, book_name) %>%
  summarize(
    total_chapters = n(),
    total_verses = sum(total_verses),
    total_characters = sum(total_characters)
  )

head(db_by_book, 3)
```

### Remo√ß√£o de objetos

Atualmente o painel *Environment* do nosso R Studio encontra-se cheio de vari√°veis sem uso:

![Painel Environment do RStudio com muitas vari√°veis](images/environment_trash.png){fig-alt="Captura de tela do painel Environment contendo muitas vari√°veis sem uso" fig-align="left"}

Para mantermos a organiza√ß√£o dos nossos objetos, iremos remover aqueles aos quais n√£o mais utilizamos atrav√©s da fun√ß√£o `rm`:

```{r}
db_by_verse <- db_full
rm(con, data, db_full, db_metadata, db_testament, db_book, db_verse, lib, libs, path, table, tables)
```

Desta forma, ficamos com o painel Environment desta forma:

![Painel Environment do RStudio com poucas vari√°veis](images/environment_clean.png){fig-alt="Captura de tela do painel Environment contendo apenas tr√™s vari√°veis" fig-align="left"}

## An√°lise de dados

Na √∫ltima etapa deste projeto, validaremos e analisaremos as informa√ß√µes contidas nos objetos `db_by_book`, `db_by_chapter` e `db_by_verse`.

Toda an√°lise √© baseada em **perguntas e constata√ß√µes por meio de observa√ß√£o**, portanto, responderemos a algumas perguntas formuladas para compreender melhor a base de dados analisada.

### Maiores e menores

Para descobrirmos qual √© o maior e o menor livro da B√≠blia, devemos entender que **a rela√ß√£o de maior/menor se d√° com base no ponto de vista abordado**, pois podemos definir o que √© "ser maior" ou "ser menor" de **forma quantitativa com base na quantidade de caracteres, vers√≠culos ou cap√≠tulos**.

Dito isso, definiremos o tamanho de cada livro com base nos tr√™s atributos mencionados acima, utilizando as seguintes colunas:

-   `total_characters` do objeto `db_by_verse`;
-   `total_verses` do objeto `db_by_chapter`;
-   `total_chapters` do objeto `db_by_book`.

#### Maior vers√≠culo com base na quantidade de caracteres

```{r}
bigger_verse_by_characters <- which.max(db_by_verse$total_characters)
db_by_verse[bigger_verse_by_characters, ]
```

#### Menor vers√≠culo com base na quantidade de caracteres

```{r}
smaller_verse_by_characters <- which.min(db_by_verse$total_characters)
db_by_verse[smaller_verse_by_characters, ]
```

#### Maior cap√≠tulo com base na quantidade de caracteres

```{r}
bigger_chapter_by_characters <- which.max(db_by_chapter$total_characters)
db_by_chapter[bigger_chapter_by_characters, ]
```

#### Menor cap√≠tulo com base na quantidade de caracteres

```{r}
smaller_chapter_by_characters <- which.min(db_by_chapter$total_characters)
db_by_chapter[smaller_chapter_by_characters, ]
```

#### Maior cap√≠tulo com base na quantidade de vers√≠culos

```{r}
bigger_chapter_by_verses <- which.max(db_by_chapter$total_verses)
db_by_chapter[bigger_chapter_by_verses, ]
```

#### Menor cap√≠tulo com base na quantidade de vers√≠culos

```{r}
smaller_chapter_by_verses <- which.min(db_by_chapter$total_verses)
db_by_chapter[smaller_chapter_by_verses, ]
```

#### Maior livro com base na quantidade de caracteres

```{r}
bigger_book_by_characters <- which.max(db_by_book$total_characters)
db_by_book[bigger_book_by_characters, ]
```

#### Menor livro com base na quantidade de caracteres

```{r}
smaller_book_by_characters <- which.min(db_by_book$total_characters)
db_by_book[smaller_book_by_characters, ]
```

#### Maior livro com base na quantidade de vers√≠culos

```{r}
bigger_book_by_verses <- which.max(db_by_book$total_verses)
db_by_book[bigger_book_by_verses, ]
```

#### Menor livro com base na quantidade de vers√≠culos

```{r}
smaller_book_by_verses <- which.min(db_by_book$total_verses)
db_by_book[smaller_book_by_verses, ]
```

#### Maior livro com base na quantidade de cap√≠tulos

```{r}
bigger_book_by_chapters <- which.max(db_by_book$total_chapters)
db_by_book[bigger_book_by_chapters, ]
```

#### Menor livro com base na quantidade de cap√≠tulos

```{r}
smaller_book_by_chapters <- which.min(db_by_book$total_chapters)
db_by_book[smaller_book_by_chapters, ]
```

#### Compilando resultados {#compilando-resultados}

Agora que capturamos os dados necess√°rios sobre os maior e menores livro da B√≠blia, vamos junt√°-los em uma matriz que nos permita uma melhor visualiza√ß√£o, e ser√° necess√°rio o uso das fun√ß√µes `c` e `matrix`:

```{r}
bigger_book_names <- c(
  db_by_book[bigger_book_by_characters, 'book_name'],
  db_by_book[bigger_book_by_verses, 'book_name'],
  db_by_book[bigger_book_by_chapters, 'book_name']
)

bigger_book_totals <- c(
  db_by_book[bigger_book_by_characters, 'total_characters'],
  db_by_book[bigger_book_by_verses, 'total_verses'],
  db_by_book[bigger_book_by_chapters, 'total_chapters']
)

smaller_book_names <- c(
  db_by_book[smaller_book_by_characters, 'book_name'],
  db_by_book[smaller_book_by_verses, 'book_name'],
  db_by_book[smaller_book_by_chapters, 'book_name']
)

smaller_book_totals <- c(
  db_by_book[smaller_book_by_characters, 'total_characters'],
  db_by_book[smaller_book_by_verses, 'total_verses'],
  db_by_book[smaller_book_by_chapters, 'total_chapters']
)

bigger_books <- matrix(c(bigger_book_names, bigger_book_totals), ncol = 2, nrow = 3)
smaller_books <- matrix(c(smaller_book_names, smaller_book_totals), ncol = 2, nrow = 3)
```

Agora vamos nomear as linhas e colunas das matrizes criadas de forma que nos permita uma melhor compreens√£o dos dados compilados, e para isto usaremos as fun√ß√µes `rownames` e `colnames`:

```{r}
size_rownames <- c("Caracteres", "Vers√≠culos", "Cap√≠tulos")
size_colnames <- c("Livro", "Total")

rownames(bigger_books) <- size_rownames
rownames(smaller_books) <- size_rownames

colnames(bigger_books) <- size_colnames
colnames(smaller_books) <- size_colnames

rm(bigger_book_names, bigger_book_totals, smaller_book_names, smaller_book_totals)
```

Por fim teremos os maiores livro da B√≠blia separados por categoria:

```{r}
# Maiores livros com base na quantidade de caracteres, vers√≠culos e cap√≠tulos
bigger_books
```

Assim como tamb√©m os menores:

```{r}
# Menores livros com base na quantidade de caracteres, vers√≠culos e cap√≠tulos
smaller_books
```

### M√©dias e medianas

A an√°lise e compara√ß√£o dos valores de m√©dia e mediana permitem **evitar interpreta√ß√µes equivocadas**, pois diferentemente da m√©dia, a **mediana ignora as metades superior e inferior**, descartando assim valores **muito discrepantes e extremos** que estejam influenciando na m√©dia.

Para ilustrar a compreens√£o da import√¢ncia da an√°lise de medianas, imagine uma pessoa dizendo a frase abaixo:

> "Minha empresa √© um √≥timo lugar para se trabalhar. L√° a m√©dia salarial √© de 6 mil reais!"

Contudo, para ilustrar a fal√°cia acima apresentada, definimos o seguinte cen√°rio:

```{r}
salary_boss <- 20000
salary_coordinator <- 10000
salary_employee_1 <- 1500
salary_employee_2 <- 1500
salary_employee_3 <- 1500
salary_employee_4 <- 1500

company_salary <- c(salary_boss, salary_coordinator, salary_employee_1, salary_employee_2, salary_employee_3, salary_employee_4)

salary_mean <- round(mean(company_salary))
salary_median <- round(median(company_salary))
salary_diff <- round(abs(salary_mean - salary_median))

paste(glue('M√©dia: {salary_mean} | Mediana: {salary_median} | Diferen√ßa: {salary_diff}'))
```

------------------------------------------------------------------------

Viu como n√∫meros n√£o mentem, mas mentirosos usam n√∫meros para mentir? üòÇ

No caso acima a m√©dia permite que os sal√°rios do chefe (`salary_boss)` e do coordenador (`salary_coordinator`) **influenciem a m√©dia final**, **enviezando a an√°lise** com uma ideia de que a faixa salarial √© alta para todos, contudo, **a mediana nos mostra que isso n√£o √© verdade**.

Com isso em mente, seguimos com nossa an√°lise baseada na B√≠blia...

#### Caracteres por vers√≠culo

```{r}
mean_characters_by_verse <- round(mean(db_by_verse[, "total_characters"]))
median_characters_by_verse <- round(median(db_by_verse[, "total_characters"]))
diff_characters_by_verse <- round(abs(mean_characters_by_verse - median_characters_by_verse))

paste(glue('M√©dia: {mean_characters_by_verse} | Mediana: {median_characters_by_verse} | Diferen√ßa: {diff_characters_by_verse}'))
```

#### Caracteres por cap√≠tulo

```{r}
mean_characters_by_chapter <- round(mean(db_by_chapter[["total_characters"]]))
median_characters_by_chapter <- round(median(db_by_chapter[["total_characters"]]))
diff_characters_by_chapter <- round(abs(mean_characters_by_chapter - median_characters_by_chapter))

paste(glue('M√©dia: {mean_characters_by_chapter} | Mediana: {median_characters_by_chapter} | Diferen√ßa: {diff_characters_by_chapter}'))
```

#### Caracteres por livro

```{r}
mean_characters_by_book <- round(mean(db_by_book[["total_characters"]]))
median_characters_by_book <- round(median(db_by_book[["total_characters"]]))
diff_characters_by_book <- round(abs(mean_characters_by_book - median_characters_by_book))

paste(glue('M√©dia: {mean_characters_by_book} | Mediana: {median_characters_by_book} | Diferen√ßa: {diff_characters_by_book}'))
```

#### Vers√≠culos por cap√≠tulo

```{r}
mean_verses_by_chapter <- round(mean(db_by_chapter[["total_verses"]]))
median_verses_by_chapter <- round(median(db_by_chapter[["total_verses"]]))
diff_verses_by_chapter <- round(abs(mean_verses_by_chapter - median_verses_by_chapter))

paste(glue('M√©dia: {mean_verses_by_chapter} | Mediana: {median_verses_by_chapter} | Diferen√ßa: {diff_verses_by_chapter}'))
```

#### Vers√≠culos por livro

```{r}
mean_verses_by_book <- round(mean(db_by_book[["total_verses"]]))
median_verses_by_book <- round(median(db_by_book[["total_verses"]]))
diff_verses_by_book <- round(abs(mean_verses_by_book - median_verses_by_book))

paste(glue('M√©dia: {mean_verses_by_book} | Mediana: {median_verses_by_book} | Diferen√ßa: {diff_verses_by_book}'))
```

#### Cap√≠tulos por livro

```{r}
mean_chapters_by_book <- round(mean(db_by_book[["total_chapters"]]))
median_chapters_by_book <- round(median(db_by_book[["total_chapters"]]))
diff_chapters_by_book <- round(abs(mean_chapters_by_book - median_chapters_by_book))

paste(glue('M√©dia: {mean_chapters_by_book} | Mediana: {median_chapters_by_book} | Diferen√ßa: {diff_chapters_by_book}'))
```

#### Compilando resultados

Assim como fizemos na [se√ß√£o anterior](#compilando-resultados "Se√ß√£o "Compilando resultados" de m√°ximos e m√≠nmos"), vamos formatar os dados obtidos de uma a permitir uma melhor visualiza√ß√£o:

```{r}
mean_median_matriz <- matrix(c(
  mean_characters_by_verse,
  median_characters_by_verse,
  diff_characters_by_verse,
  mean_characters_by_chapter,
  median_characters_by_chapter,
  diff_characters_by_chapter,
  mean_characters_by_book,
  median_characters_by_book,
  diff_characters_by_book,
  mean_verses_by_chapter  ,
  median_verses_by_chapter  ,
  diff_verses_by_chapter,
  mean_verses_by_book,
  median_verses_by_book,
  diff_verses_by_book,
  mean_chapters_by_book,
  median_chapters_by_book,
  diff_chapters_by_book
), ncol = 3, byrow = TRUE)

colnames(mean_median_matriz) <- c("M√©dia", "Mediana", "Diferen√ßa")
rownames(mean_median_matriz) <- c(
  'Caracteres por vers√≠culo',
  'Caracteres por cap√≠tulo',
  'Caracteres por livro',
  'Vers√≠culos por cap√≠tulo',
  'Vers√≠culos por livro',
  'Cap√≠tulos por livro'
)

mean_median_matriz
```

Agora filtraremos apenas indicadores que tenham o valor intermedi√°rio (desvio) entre m√©dia e mediana menor que 10%:

```{r}
less_than_10 <- mean_median_matriz[, 'Diferen√ßa'] / ((mean_median_matriz[, 'M√©dia'] + mean_median_matriz[, 'Mediana']) / 2) * 100 < 10
mean_median_matriz[less_than_10, ]
```

Esta matriz nos permite inferir que na B√≠blia temos um valor intermedi√°rio comum para caracteres por vers√≠culo (133) e cap√≠tulo (3103), assim como vers√≠culos por cap√≠tulo (25).

### Conclus√£o {#conclus√£o}

Ap√≥s a obten√ß√£o de tantos dados, conseguimos chegar as seguintes conclus√µes:

1.  O maior livro da B√≠blia √© o livro de Salmos do `r db_by_book %>% filter(book_name == "Salmos") %>% pull(testament_name)`, tendo `r db_by_book %>% filter(book_name == "Salmos") %>% pull(total_characters)` caracteres, `r db_by_book %>% filter(book_name == "Salmos") %>% pull(total_verses)` vers√≠culos e `r db_by_book %>% filter(book_name == "Salmos") %>% pull(total_chapters)` cap√≠tulos;
2.  O menor livro da da B√≠blia em quantidade de caracteres √© o livro de `r db_by_book[smaller_book_by_characters, ]$book_name` do `r db_by_book[smaller_book_by_characters, ]$testament_name`, com um total de `r db_by_book[smaller_book_by_characters, ]$total_characters` caracteres;
3.  O menor livro da da B√≠blia em quantidade de vers√≠culos √© o livro de `r db_by_book[smaller_book_by_verses, ]$book_name` do `r db_by_book[smaller_book_by_verses, ]$testament_name`, com um total de `r db_by_book[smaller_book_by_verses, ]$total_verses` caracteres;
4.  O menor livro da da B√≠blia em quantidade de cap√≠tulos √© o livro de `r db_by_book[smaller_book_by_chapters, ]$book_name` do `r db_by_book[smaller_book_by_chapters, ]$testament_name`, com um total de `r db_by_book[smaller_book_by_chapters, ]$total_chapters` caracteres;
5.  O menor vers√≠culo da B√≠blia tem `r db_by_verse[smaller_verse_by_characters, ]$total_characters` caracteres e fica no livro de `r db_by_verse[smaller_verse_by_characters, ]$book_name` no `r db_by_verse[smaller_verse_by_characters, ]$testament_name`;
6.  O maior vers√≠culo da B√≠blia tem `r db_by_verse[bigger_verse_by_characters, ]$total_characters` caracteres e fica no livro de `r db_by_verse[bigger_verse_by_characters, ]$book_name` no `r db_by_verse[bigger_verse_by_characters, ]$testament_name`;
7.  A B√≠blia tem um total de `r db_by_book %>% nrow()` livros, sendo `r db_by_book %>% filter(testament_name == 'Novo Testamento') %>% nrow()` (`r round(db_by_book %>% filter(testament_name == 'Novo Testamento') %>% nrow() / db_by_book %>% nrow() * 100)`%) do Antigo Testamento e `r db_by_book %>% filter(testament_name == 'Antigo Testamento') %>% nrow()` do Novo Testamento (`r round(db_by_book %>% filter(testament_name == 'Antigo Testamento') %>% nrow() / db_by_book %>% nrow() * 100)`%).

### Ponto de aten√ß√£o

Ô∏èOs dados que voc√™ leu na se√ß√£o [Conclus√£o](#conclus√£o "√Çncora para a se√ß√£o Conclus√£o") foram escritos utilizando *inline code*, isto posto, caso voc√™ avalie o script do projeto no GitHub, ver√° que os dados n√£o est√£o fixados no c√≥digo, mas sim obtidos atrav√©s de vari√°veis capturadas anteriormente:

![Inline-code para c√≥digo incorporado ao texto](images/inline_code.png){fig-alt="Se√ß√£o Conclus√£o escrita com c√≥digo incorporado ao texto"}

### Observa√ß√µes finais

Espero que este projeto possa ser √∫til tanto para aqueles que desejam explorar dados ou aprender mais sobre a B√≠blia, quanto para quem busca aprimorar seus conhecimentos em R.
